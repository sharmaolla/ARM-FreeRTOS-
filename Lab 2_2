#include <iostream>
#include <sstream>
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "hardware/gpio.h"
#include "PicoOsUart.h"
#include "ssd1306.h"
#include "pico/stdlib.h"
#include "queue.h"
#include "pico/stdio.h"
#include <cstdio>
#include "hardware/timer.h"
#include "pico/time.h"

#define RotSW 12
#define Rot_A 10
#define Rot_B 11


extern "C" {
uint32_t read_runtime_ctr(void) {
    return timer_hw->timerawl;
}
}

QueueHandle_t queue;
QueueHandle_t q_between_tasks;

typedef struct{
    uint PIN;
    bool status;
    int frequency;

}LED_param;

void Rot_ISR(uint gpio, uint32_t events){
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    static absolute_time_t last_time = nil_time;
    int ev;
    bool send = false;
    if(gpio == RotSW && (events & GPIO_IRQ_EDGE_FALL) && absolute_time_diff_us(last_time, get_absolute_time())>= 300000){
        ev = 0;
        send = true;
        last_time = get_absolute_time();
    }
    else if (gpio == Rot_A && (events & GPIO_IRQ_EDGE_RISE) && gpio_get(Rot_B) == 0){
        ev = 1;
        send = true;
    }
    else if (gpio == Rot_A && (events & GPIO_IRQ_EDGE_RISE) && gpio_get(Rot_B) == 1){
        ev = -1;
        send = true;
    }
    if(send){
        xQueueSendFromISR(queue, &ev, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}

// TASK 1----------------------------------------------

static void ReadQ(void *pvParameters){
    auto *led = static_cast<LED_param *>(pvParameters);
    int received;
    int send;
    while(1){
        if(xQueueReceive(queue, &received,portMAX_DELAY)){
            if(received == 0){
                led->status = ! led->status;
                printf("Button was pressed.\n");
                send = led->status;
                //xQueueSend(q_between_tasks, &status, 0);

            }
            else if(received == 1){
                led->frequency++;

            }
            else if(received == -1){
               led->frequency--;
            }
            if(led->frequency > 200){
                led->frequency = 200;
            }
            if(led->frequency < 2){
                led->frequency = 2;
            }
            printf("LED is blinking at %d Hz\n", led->frequency);
            send = led->frequency;
            xQueueSend(q_between_tasks, &send, 0);
        }
        else{
            vTaskDelay(pdMS_TO_TICKS(1));
        }
    }
}



// TASK 2 -------------------------------------------------

static void HandleLED(void *pvParameters){
    auto *led = static_cast<LED_param *>(pvParameters);
    int msg;
    int HalfPeriod = 500/ led->frequency;

        while(1){
            if (xQueueReceive(q_between_tasks, &msg, 0) == pdTRUE){
                if(msg >= 2){
                    led->frequency = msg;
                    HalfPeriod = 500/ msg;

                }
                else if(msg == 1){
                    led->status = true;
                }
                else if(msg == 0){
                    led->status = false;
                }
            }
            else{

                if(led->status == false){
                    vTaskDelay(pdMS_TO_TICKS(1));
                }
                else{
                    //printf("LED: %d\n", led->status);
                    gpio_put(led->PIN, true);
                    vTaskDelay(pdMS_TO_TICKS(HalfPeriod));
                    gpio_put(led->PIN, false);
                    vTaskDelay(pdMS_TO_TICKS(HalfPeriod));
                }

            }
        }
}

static void HandleLED_old(void *pvParameters){
    auto *led = static_cast<LED_param *>(pvParameters);


    while(1){

        if(led->status && led->frequency != 0 ){ // queue
            int HalfPeriod = 500/led->frequency;
            gpio_put(led->PIN, true);
            vTaskDelay(pdMS_TO_TICKS(HalfPeriod));
            gpio_put(led->PIN, false);
            vTaskDelay(pdMS_TO_TICKS(HalfPeriod));
        }
        else{
            //led->status = false;
            gpio_put(led->PIN, false); //
        }
    }
}



int main(){

    queue = xQueueCreate(10, sizeof (int));
    q_between_tasks = xQueueCreate(10, sizeof(int));

    gpio_init(RotSW);
    gpio_set_dir(RotSW, GPIO_IN);
    gpio_pull_up(RotSW);

    gpio_init(Rot_A);
    gpio_set_dir(Rot_A, GPIO_IN);

    gpio_init(Rot_B);
    gpio_set_dir(Rot_B, GPIO_IN);


    LED_param led = {21,true, 2};
    gpio_init(led.PIN);
    gpio_set_dir(led.PIN, GPIO_OUT);
    gpio_put(led.PIN, false);

    stdio_init_all();

    printf("Boot...\n");

    gpio_set_irq_enabled_with_callback(RotSW, GPIO_IRQ_EDGE_FALL,true, &Rot_ISR);
    gpio_set_irq_enabled_with_callback(Rot_A, GPIO_IRQ_EDGE_RISE, true, &Rot_ISR);
    xTaskCreate(ReadQ, "Read Queue", 1000, &led, 1, nullptr);
    xTaskCreate(HandleLED, "Handle LED", 1000, &led, 1, nullptr);

    vTaskStartScheduler();

    while(1){}

}
