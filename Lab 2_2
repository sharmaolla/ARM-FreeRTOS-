#include <iostream>
#include <sstream>
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "hardware/gpio.h"
#include "PicoOsUart.h"
#include "ssd1306.h"
#include "pico/stdlib.h"
#include "queue.h"
#include "pico/stdio.h"
#include <cstdio>
#include "hardware/timer.h"
#include "pico/time.h"

#define RotSW 12
#define Rot_A 10
#define Rot_B 11


extern "C" {
uint32_t read_runtime_ctr(void) {
    return timer_hw->timerawl;
}
}
QueueHandle_t queue;

typedef struct{
    uint PIN;
    bool status;
    int frequency;
}LED_param;

void Rot_ISR(uint gpio, uint32_t events){
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    static absolute_time_t last_time = nil_time;
    int ev;
    bool send = false;
    if(gpio == RotSW && (events & GPIO_IRQ_EDGE_FALL) && absolute_time_diff_us(last_time, get_absolute_time())>= 300000){
        ev = 0;
        send = true;
        last_time = get_absolute_time();
    }
    else if (gpio == Rot_A && (events & GPIO_IRQ_EDGE_RISE) && gpio_get(Rot_B) == 0){
        ev = 1;
        send = true;
    }
    else if (gpio == Rot_A && (events & GPIO_IRQ_EDGE_RISE) && gpio_get(Rot_B) == 1){
        ev = -1;
        send = true;
    }
    if(send){
        xQueueSendFromISR(queue, &ev, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}

// TASK 1----------------------------------------------

static void ReadQ(void *pvParameters){
    auto *led = static_cast<LED_param *>(pvParameters);
    int received;
    while(1){
        if(xQueueReceive(queue, &received,portMAX_DELAY)){
            if(received == 0){
                led->status = ! led->status;
                printf("Button was pressed.\n");
            }
            else if(received == 1){
                led->frequency++;
            }
            else if(received == -1){
               led->frequency--;
            }
            if(led->frequency > 200){
                led->frequency = 200;
            }
            if(led->frequency < 0){
                led->frequency = 0;
            }
            printf("LED is blinking at %d Hz\n", led->frequency);
        }
    }
}

// TASK 2 -------------------------------------------------

static void HandleLED(void *pvParameters){
    auto *led = static_cast<LED_param *>(pvParameters);

    while(1){
        if(led->status && led->frequency != 0 ){
            int HalfPeriod = 500/led->frequency;
            gpio_put(led->PIN, true);
            vTaskDelay(pdMS_TO_TICKS(HalfPeriod));
            gpio_put(led->PIN, false);
            vTaskDelay(pdMS_TO_TICKS(HalfPeriod));
        }
        else{
            //led->status = false;
            gpio_put(led->PIN, false);
        }
    }
}



int main(){

    queue = xQueueCreate(10, sizeof (int));

    gpio_init(RotSW);
    gpio_set_dir(RotSW, GPIO_IN);
    gpio_pull_up(RotSW);

    gpio_init(Rot_A);
    gpio_set_dir(Rot_A, GPIO_IN);

    gpio_init(Rot_B);
    gpio_set_dir(Rot_B, GPIO_IN);


    LED_param led = {21,false, 0};
    gpio_init(led.PIN);
    gpio_set_dir(led.PIN, GPIO_OUT);
    gpio_put(led.PIN, false);

    stdio_init_all();

    printf("Boot...\n");

    gpio_set_irq_enabled_with_callback(RotSW, GPIO_IRQ_EDGE_FALL,true, &Rot_ISR);
    gpio_set_irq_enabled_with_callback(Rot_A, GPIO_IRQ_EDGE_RISE, true, &Rot_ISR);
    xTaskCreate(ReadQ, "Read Queue", 1000, &led, 1, nullptr);
    xTaskCreate(HandleLED, "Handle LED", 1000, &led, 1, nullptr);

    vTaskStartScheduler();

    while(1){}

}
